// Generated by CoffeeScript 1.7.1
var Struct,
  __slice = [].slice;

Struct = (function() {
  Struct.prototype.endian = 'BE';

  function Struct(format, fill) {
    var count, fmt, i, offset, _i, _j, _len, _ref;
    this.format = format;
    this.fill = fill != null ? fill : null;
    this.fmts = [];
    offset = 0;
    if (format[0] === '>') {
      this.endian = 'BE';
      format = format.slice(1);
    } else if (format[0] === '<') {
      this.endian = 'LE';
      format = format.slice(1);
    }
    _ref = format.match(/\d*\S/g);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      fmt = _ref[_i];
      if (fmt.length > 1) {
        count = parseInt(fmt);
        fmt = fmt[fmt.length - 1];
      } else {
        count = 1;
      }
      if (fmt === 's' || fmt === 'R') {
        this.fmts.push([offset, fmt, count]);
        offset += count;
        continue;
      }
      for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {
        switch (fmt) {
          case 'x':
            offset += 1;
            break;
          case 'b':
          case 'B':
            this.fmts.push([offset, fmt, 1]);
            offset += 1;
            break;
          case 'h':
          case 'H':
            this.fmts.push([offset, fmt, 2]);
            offset += 2;
            break;
          case 'i':
          case 'I':
            this.fmts.push([offset, fmt, 4]);
            offset += 4;
            break;
          case 'f':
            this.fmts.push([offset, fmt, 4]);
            offset += 4;
            break;
          case 'd':
            this.fmts.push([offset, fmt, 8]);
            offset += 8;
            break;
          default:
            throw new Error("bad format charactor '" + fmt + "'");
        }
      }
    }
    this.size = offset;
  }

  Struct.prototype.pack = function() {
    var buff, count, fmt, fmts, i, offset, size, value, values, _i, _j, _ref, _ref1;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    buff = new Buffer(this.size);
    if (this.fill !== null) {
      buff.fill(this.fill);
    }
    count = values.length;
    fmts = this.fmts;
    if (count !== fmts.length) {
      console.log(fmts);
      throw new Error("need " + fmts.length + " values to pack, but got " + count);
    }
    if (this.endian === 'BE') {
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        _ref = fmts[i], offset = _ref[0], fmt = _ref[1], size = _ref[2];
        value = values[i];
        switch (fmt) {
          case 'b':
            buff.writeInt8(value, offset);
            break;
          case 'B':
            buff.writeUInt8(value, offset);
            break;
          case 'h':
            buff.writeInt16BE(value, offset);
            break;
          case 'H':
            buff.writeUInt16BE(value, offset);
            break;
          case 'i':
            buff.writeInt32BE(value, offset);
            break;
          case 'I':
            buff.writeUInt32BE(value, offset);
            break;
          case 'f':
            buff.writeFloatBE(value, offset);
            break;
          case 'd':
            buff.writeDoubleBE(value, offset);
            break;
          case 's':
            buff.write(value, offset, Math.min(value.length, size), 'utf8');
            break;
          case 'R':
            value.copy(buff, offset, 0, Math.min(value.length, size));
        }
      }
    } else {
      for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {
        _ref1 = fmts[i], offset = _ref1[0], fmt = _ref1[1], size = _ref1[2];
        value = values[i];
        switch (fmt) {
          case 'b':
            buff.writeInt8(value, offset);
            break;
          case 'B':
            buff.writeUInt8(value, offset);
            break;
          case 'h':
            buff.writeInt16LE(value, offset);
            break;
          case 'H':
            buff.writeUInt16LE(value, offset);
            break;
          case 'i':
            buff.writeInt32LE(value, offset);
            break;
          case 'I':
            buff.writeUInt32LE(value, offset);
            break;
          case 'f':
            buff.writeFloatLE(value, offset);
            break;
          case 'd':
            buff.writeDoubleLE(value, offset);
            break;
          case 's':
            buff.write(value, offset, Math.min(value.length, size), 'utf8');
            break;
          case 'R':
            value.copy(buff, offset, 0, Math.min(value.length, size));
        }
      }
    }
    return buff;
  };

  Struct.prototype.unpack = function(buff) {
    var fmt, fmts, offset, results, size, _i, _j, _len, _len1, _ref, _ref1;
    fmts = this.fmts;
    results = [];
    if (this.endian === 'BE') {
      for (_i = 0, _len = fmts.length; _i < _len; _i++) {
        _ref = fmts[_i], offset = _ref[0], fmt = _ref[1], size = _ref[2];
        switch (fmt) {
          case 'b':
            results.push(buff.readInt8(offset));
            break;
          case 'B':
            results.push(buff.readUInt8(offset));
            break;
          case 'h':
            results.push(buff.readInt16BE(offset));
            break;
          case 'H':
            results.push(buff.readUInt16BE(offset));
            break;
          case 'i':
            results.push(buff.readInt32BE(offset));
            break;
          case 'I':
            results.push(buff.readUInt32BE(offset));
            break;
          case 'f':
            results.push(buff.readFloatBE(offset));
            break;
          case 'd':
            results.push(buff.readDoubleBE(offset));
            break;
          case 's':
            results.push(buff.toString('utf8', offset, offset + size));
            break;
          case 'R':
            results.push(buff.slice(offset, offset + size));
        }
      }
    } else {
      for (_j = 0, _len1 = fmts.length; _j < _len1; _j++) {
        _ref1 = fmts[_j], offset = _ref1[0], fmt = _ref1[1], size = _ref1[2];
        switch (fmt) {
          case 'b':
            results.push(buff.readInt8(offset));
            break;
          case 'B':
            results.push(buff.readUInt8(offset));
            break;
          case 'h':
            results.push(buff.readInt16LE(offset));
            break;
          case 'H':
            results.push(buff.readUInt16LE(offset));
            break;
          case 'i':
            results.push(buff.readInt32LE(offset));
            break;
          case 'I':
            results.push(buff.readUInt32LE(offset));
            break;
          case 'f':
            results.push(buff.readFloatLE(offset));
            break;
          case 'd':
            results.push(buff.readDoubleLE(offset));
            break;
          case 's':
            results.push(buff.toString('utf8', offset, offset + size));
            break;
          case 'R':
            results.push(buff.slice(offset, offset + size));
        }
      }
    }
    return results;
  };

  return Struct;

})();

module.exports = Struct;
